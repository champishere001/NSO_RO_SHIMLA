<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
  <title>UFS | Weekly + Monthly (XLSX, SRO week-wise edits)</title>

  <!-- Firebase (for saving week-wise edits) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <!-- SheetJS (read XLSX from same folder; no upload needed) -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#020617; --panel:#0f172a; --card:#1e293b; --border:#334155;
      --accent:#38bdf8; --v1:#10b981; --text:#f8fafc; --dim:#94a3b8;
      --warn:#f59e0b; --danger:#ef4444;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:'Plus Jakarta Sans',sans-serif; background:var(--bg); color:var(--text); height:100vh; height:100dvh; overflow:hidden; }
    .root{ height:100%; display:flex; overflow:hidden; }

    aside{
      width:380px; min-width:380px; background:var(--panel);
      border-right:1px solid var(--border); display:flex; flex-direction:column;
    }
    .aside-head{
      padding:16px; border-bottom:1px solid rgba(255,255,255,.06);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .brand b{ color:var(--accent); letter-spacing:1px; }
    .brand div{ margin-top:6px; font-size:11px; color:rgba(248,250,252,.70); font-weight:700; line-height:1.35; }
    .aside-body{ padding:14px 16px 16px; overflow:auto; display:grid; gap:12px; }

    .card{
      background:rgba(30,41,59,.45);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;
      box-shadow:0 12px 32px rgba(0,0,0,.25);
    }
    .card h3{
      margin:0 0 10px; font-size:12px; font-weight:1000; letter-spacing:.8px;
      text-transform:uppercase; color:rgba(248,250,252,.85);
    }
    .muted{ font-size:11px; color:rgba(248,250,252,.65); font-weight:700; line-height:1.45; }
    .row{ display:grid; gap:8px; }

    .input, select{
      width:100%; background:#000; border:1px solid rgba(255,255,255,.12);
      color:#fff; padding:10px; border-radius:10px; outline:none; font-weight:900; font-size:12px;
    }
    .btn{
      border:none; border-radius:10px; padding:10px 12px;
      font-weight:1000; cursor:pointer; font-size:12px;
    }
    .btn-soft{ background:rgba(255,255,255,.10); color:#fff; border:1px solid rgba(255,255,255,.12); }
    .btn-accent{ background:var(--accent); color:#000; }
    .btn-warn{ background:var(--warn); color:#000; }
    .btn-green{ background:var(--v1); color:#000; }
    .btn-danger{ background:var(--danger); color:#fff; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      color:rgba(248,250,252,.85);
      font-size:11px; font-weight:1000;
    }

    main{ flex:1; display:flex; flex-direction:column; overflow:hidden; }
    header{
      padding:12px 16px;
      background:rgba(15,23,42,.92);
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; gap:10px;
    }
    header .title{ font-weight:1000; letter-spacing:1px; color:var(--accent); }
    header .grow{ flex:1; }
    header input[type="date"]{ color-scheme:dark; }

    .tabs{
      display:flex; gap:8px; padding:12px 16px;
      border-bottom:1px solid rgba(255,255,255,.06);
      background:rgba(15,23,42,.70);
    }
    .tab{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      color:rgba(248,250,252,.85);
      font-weight:1000; font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{ background:var(--accent); color:#000; border-color:rgba(56,189,248,.6); }

    .workspace{ flex:1; padding:14px 16px 18px; overflow:auto; }
    .table-wrap{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:auto;
      box-shadow:0 16px 40px rgba(0,0,0,.35);
    }
    table{ width:100%; border-collapse:separate; border-spacing:0; min-width:1200px; }
    th{
      position:sticky; top:0; z-index:10;
      background:#0b1220;
      color:var(--accent);
      font-size:11px;
      text-transform:uppercase;
      font-weight:1000;
      letter-spacing:.8px;
      padding:14px 12px;
      border-bottom:2px solid rgba(56,189,248,.65);
      white-space:nowrap;
      text-align:left;
    }
    td{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      color:rgba(248,250,252,.78);
      font-size:12px;
      vertical-align:top;
    }

    .cell input{
      width:100%;
      background:#000;
      border:1px solid rgba(255,255,255,.12);
      color:#fff;
      padding:8px 10px;
      border-radius:10px;
      outline:none;
      font-weight:900;
      font-size:12px;
    }
    .locked input{ opacity:.70; border:1px dashed rgba(56,189,248,.35); }
    .readonly input{ opacity:.55; }
    .editable input{ border:1px solid rgba(16,185,129,.45); box-shadow:0 0 0 2px rgba(16,185,129,.12) inset; }

    #loadingOverlay{
      display:none; position:fixed; inset:0;
      background:rgba(2,6,23,.92);
      z-index:9999;
      align-items:center; justify-content:center;
      flex-direction:column;
      color:var(--accent);
    }
    .spin{
      width:42px; height:42px;
      border:4px solid rgba(56,189,248,.16);
      border-left-color:var(--accent);
      border-radius:50%;
      animation:spin 1s linear infinite;
      margin-bottom:12px;
    }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    .note{
      border:1px dashed rgba(255,255,255,.16);
      border-radius:12px;
      padding:10px;
      background:rgba(0,0,0,.18);
      color:rgba(248,250,252,.75);
      font-size:11px;
      font-weight:800;
      line-height:1.45;
    }
    code{ background:rgba(0,0,0,.25); padding:2px 6px; border-radius:8px; }
  </style>
</head>

<body>
<div id="loadingOverlay">
  <div class="spin"></div>
  <div id="loadingText" style="font-weight:1000; letter-spacing:2px; font-size:12px;">LOADING...</div>
</div>

<div class="root">
  <!-- LEFT CONSOLE -->
  <aside>
    <div class="aside-head">
      <div class="brand">
        <b>UFS (WEEKLY + MONTHLY)</b>
        <div>
          XLSX auto-pick (no upload). Weekly shows edits (week-wise) per SRO.<br>
          Monthly auto-built from Weekly + Monthly Template (read-only).
        </div>
      </div>
      <button class="btn btn-soft" onclick="reloadAll()">‚Üª</button>
    </div>

    <div class="aside-body">
      <div class="card">
        <h3>Files (same folder)</h3>
        <div class="note">
          Put these files in the <b>same folder</b> as this HTML (GitHub Pages):<br>
          ‚Ä¢ <code>Weekly MPR RO Shimla Level.xlsx</code><br>
          ‚Ä¢ <code>UFS MPR Monthly RO Shimla.xlsx</code>
        </div>
      </div>

      <div class="card">
        <h3>Week + SRO</h3>
        <div class="row">
          <label class="muted">Week Ending Date (key for saving edits)</label>
          <input id="weekEnding" class="input" type="date" />

          <label class="muted">Select SRO (no password)</label>
          <select id="sroSelect" class="input" onchange="setSroUser(this.value)">
            <option value="">-- Select SRO --</option>
            <option value="Shimla">Shimla</option>
            <option value="Dharamshala">Dharamshala</option>
            <option value="Mandi">Mandi</option>
            <option value="Hamirpur">Hamirpur</option>
          </select>

          <div class="pill" id="whoPill">SRO: Not selected</div>
          <div class="muted">
            Weekly edit allowed only for selected SRO + selected week. (No password)
          </div>
        </div>
      </div>

      <div class="card">
        <h3>What is editable?</h3>
        <div class="muted" id="editableHint">
          Only <b>‚Äúduring week‚Äù</b> metrics in Weekly are editable per SRO (recommended).
        </div>
      </div>

      <div class="card">
        <h3>Actions</h3>
        <div class="row">
          <button class="btn btn-accent" onclick="reloadAll()">üîÑ Reload Weekly + Monthly</button>
          <button class="btn btn-warn" onclick="downloadXlsx('weekly')">‚¨áÔ∏è Export Weekly (XLSX)</button>
          <button class="btn btn-warn" onclick="downloadXlsx('monthly')">‚¨áÔ∏è Export Monthly (XLSX)</button>
          <button class="btn btn-green" onclick="saveMonthlySnapshot()">‚òÅÔ∏è Save Monthly Snapshot (Firebase)</button>
          <button class="btn btn-soft" onclick="clearEditsForThisWeek()">üßπ Clear THIS week edits (selected SRO)</button>
        </div>
      </div>

      <div class="card">
        <h3>Search</h3>
        <input id="q" class="input" placeholder="Search in active table..." oninput="renderActive()" />
      </div>
    </div>
  </aside>

  <!-- RIGHT -->
  <main>
    <header>
      <div class="title">UFS Weekly & Monthly</div>
      <div class="grow"></div>
      <span class="pill" id="monthPill">Month: --</span>
      <input type="date" id="sysDate" />
      <button class="btn btn-soft" onclick="setToday()">Today</button>
    </header>

    <div class="tabs">
      <button class="tab active" id="tabWeekly" onclick="setTab('weekly')">Weekly (editable)</button>
      <button class="tab" id="tabMonthly" onclick="setTab('monthly')">Monthly (auto)</button>
    </div>

    <div class="workspace">
      <div class="table-wrap">
        <table>
          <thead><tr id="tableHeader"></tr></thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>
  </main>
</div>

<script>
/* =========================
   FILES (XLSX in same folder)
========================== */
const WEEKLY_XLSX_URL  = "Weekly MPR RO Shimla Level.xlsx";
const MONTHLY_XLSX_URL = "UFS MPR Monthly RO Shimla.xlsx";

/* =========================
   FIREBASE
========================== */
const firebaseConfig = {
  apiKey: "AIzaSyB6fQ8n4qyG-TfVdAqWtDped17bMYTZSgI",
  authDomain: "action-plan-62fae.firebaseapp.com",
  databaseURL: "https://action-plan-62fae-default-rtdb.firebaseio.com",
  projectId: "action-plan-62fae"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* =========================
   STATE
========================== */
const STATE_NAME = "HIMACHAL PRADESH";
const UFS_SRO_LIST = ["Shimla","Dharamshala","Mandi","Hamirpur"];

let activeTab = "weekly";
let currentSroUser = "";
let sysDateStr = new Date().toISOString().slice(0,10);

let weeklyWb = null, weeklySheetName = null, weeklyGridRaw = null;
let monthlyWb = null, monthlySheetName = null, monthlyGridTemplate = null;

let weeklyHeaderRowIdx = null;
let weeklyHeader = [];          // header array
let weeklyDataRows = [];        // array of { rIndex, rowArr, sroName, isData }
let weeklyColMap = {};          // semantic -> col index

let weeklyEdits = {};           // loaded from firebase for selected week: key = `${sro}::${r}_${c}` -> value
let monthlyGridComputed = null; // computed 2D

// Default weekly columns if header detection fails (based on your earlier structure)
const WEEKLY_FALLBACK = {
  sl: 0,
  sro: 1,
  townsPhase: 2,
  townsDuring: 3,
  completedSince: 4,
  underSurvey: 5,
  pct: 6,
  blocksDuring: 7,
  blocksSince: 8,
  allRespectDuring: 9,
  allRespectSince: 10,
  dispatchedDuring: 11,
  dispatchedSince: 12
};

// Weekly columns that are editable (week-wise) for each SRO
// We choose "during week" values only (best practice)
let WEEKLY_EDITABLE_COLS = new Set(); // filled after header map ready

// Monthly columns (template positions) to fill (0-index)
const MONTHLY_MAP_COLS = {
  townsPhase: 2,
  townsDuringMonth: 3,     // sum of weekly during
  completedSince: 6,       // latest weekly since
  underSurvey: 7,          // latest weekly since
  pct: 8,                  // calc
  blocksDuringMonth: 9,    // sum of weekly during
  blocksSince: 10,         // latest weekly since
  allRespectDuringMonth: 23,
  allRespectSince: 24,
  dispatchedDuringMonth: 25,
  dispatchedSince: 26
};

/* =========================
   UI HELPERS
========================== */
function toggleLoader(show, text="PLEASE WAIT..."){
  const o = document.getElementById("loadingOverlay");
  document.getElementById("loadingText").innerText = text;
  o.style.display = show ? "flex" : "none";
}
function setToday(){
  sysDateStr = new Date().toISOString().slice(0,10);
  document.getElementById("sysDate").value = sysDateStr;
  updateMonthPill();
  renderActive();
}
function updateMonthPill(){
  const d = new Date(sysDateStr);
  const m = d.toLocaleString("en", { month:"long" });
  const y = d.getFullYear();
  document.getElementById("monthPill").innerText = `Month: ${m} ${y}`;
}
function escapeHtml(s){
  return (s ?? "").toString()
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function escapeAttr(s){ return escapeHtml(s); }
function safeText(s){ return (s ?? "").toString().trim(); }

function setTab(tab){
  activeTab = tab;
  document.getElementById("tabWeekly").classList.toggle("active", tab==="weekly");
  document.getElementById("tabMonthly").classList.toggle("active", tab==="monthly");
  renderActive();
}
function setSroUser(val){
  currentSroUser = (val || "").trim();
  document.getElementById("whoPill").innerText = currentSroUser ? `SRO: ${currentSroUser}` : "SRO: Not selected";
  renderActive();
}

function getWeekKey(){
  const v = document.getElementById("weekEnding").value;
  return v || "";
}
function requireWeekKey(){
  const wk = getWeekKey();
  if(!wk){
    alert("Select Week Ending Date first.");
    return null;
  }
  return wk;
}
function numeric(x){
  const t = (x ?? "").toString().replace(/[%\s,]/g,"").trim();
  if(!t) return 0;
  const n = Number(t);
  return Number.isFinite(n) ? n : 0;
}

/* =========================
   XLSX LOADERS (NO UPLOAD)
========================== */
async function fetchArrayBuffer(url){
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error(`File not found: ${url}`);
  return await res.arrayBuffer();
}
function sheetToGrid(wb, sheetName){
  const sheet = wb.Sheets[sheetName];
  return XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true, defval: "" });
}
async function loadXlsxFiles(){
  toggleLoader(true, "LOADING XLSX...");

  try{
    const wb1 = XLSX.read(await fetchArrayBuffer(WEEKLY_XLSX_URL), { type:"array" });
    const wb2 = XLSX.read(await fetchArrayBuffer(MONTHLY_XLSX_URL), { type:"array" });

    weeklyWb = wb1; weeklySheetName = wb1.SheetNames[0];
    monthlyWb = wb2; monthlySheetName = wb2.SheetNames[0];

    weeklyGridRaw = sheetToGrid(weeklyWb, weeklySheetName);
    monthlyGridTemplate = sheetToGrid(monthlyWb, monthlySheetName);

    prepareWeeklyStructure();
    prepareWeeklyEditableCols();
  } finally {
    toggleLoader(false);
  }
}

/* =========================
   WEEKLY: HEADER DETECT + MAP
========================== */
function findWeeklyHeaderRow(grid){
  // Find a row that contains both "SRO" and "Towns" (or similar)
  let best = -1, bestScore = -1;
  for(let r=0;r<Math.min(grid.length, 40);r++){
    const row = grid[r] || [];
    const joined = row.map(x => (x ?? "").toString().toLowerCase()).join(" | ");
    let score = 0;
    if(joined.includes("sro")) score += 3;
    if(joined.includes("town")) score += 3;
    if(joined.includes("block")) score += 2;
    if(joined.includes("dispatch")) score += 2;
    if(joined.includes("since")) score += 1;
    if(score > bestScore){
      bestScore = score; best = r;
    }
  }
  return best >= 0 ? best : 0;
}

function buildColMapFromHeader(header){
  // Try to map semantic keys using header text
  const idxOf = (preds) => {
    for(let i=0;i<header.length;i++){
      const h = (header[i] ?? "").toString().toLowerCase();
      if(!h) continue;
      if(preds.some(p => h.includes(p))) return i;
    }
    return -1;
  };

  const m = {};
  m.sl = idxOf(["sl", "s.no", "sno", "sr no", "s. no"]);
  m.sro = idxOf(["sro"]);
  m.townsPhase = idxOf(["towns phase", "phase towns", "towns in phase", "towns (phase)"]);
  m.townsDuring = idxOf(["towns in field", "during week", "during the week", "during"]);
  m.completedSince = idxOf(["completed since", "since start", "completed (since"]);
  m.underSurvey = idxOf(["under survey", "under-survey"]);
  m.pct = idxOf(["%", "percent"]);
  m.blocksDuring = idxOf(["blocks formed during", "blocks during", "during blocks"]);
  m.blocksSince = idxOf(["blocks formed since", "blocks since", "since blocks"]);
  m.allRespectDuring = idxOf(["all respect during", "all-respect during", "all respect (during"]);
  m.allRespectSince = idxOf(["all respect since", "all-respect since", "all respect (since"]);
  m.dispatchedDuring = idxOf(["dispatched during", "dispatch during", "dispatches during"]);
  m.dispatchedSince = idxOf(["dispatched since", "dispatch since", "dispatches since"]);

  // Fill missing with fallback
  for(const k of Object.keys(WEEKLY_FALLBACK)){
    if(!(k in m) || m[k] === -1) m[k] = WEEKLY_FALLBACK[k];
  }
  return m;
}

function prepareWeeklyStructure(){
  weeklyHeaderRowIdx = findWeeklyHeaderRow(weeklyGridRaw);
  weeklyHeader = (weeklyGridRaw[weeklyHeaderRowIdx] || []).map(x => (x ?? "").toString().trim());

  weeklyColMap = buildColMapFromHeader(weeklyHeader);

  // Extract data rows (we assume after header row)
  weeklyDataRows = [];
  for(let r=weeklyHeaderRowIdx+1;r<weeklyGridRaw.length;r++){
    const row = weeklyGridRaw[r] || [];
    // Data row condition: first cell numeric or SRO present
    const slCell = safeText(row[weeklyColMap.sl]);
    const sroCell = safeText(row[weeklyColMap.sro]);
    const isData = (/^\d+$/.test(slCell) && !!sroCell);

    if(isData){
      weeklyDataRows.push({
        rIndex: r,
        rowArr: row,
        sroName: sroCell,
        isData: true
      });
    }
  }
}

function prepareWeeklyEditableCols(){
  // Editable = "during week" columns. Use header map.
  const cols = [
    weeklyColMap.townsDuring,
    weeklyColMap.blocksDuring,
    weeklyColMap.allRespectDuring,
    weeklyColMap.dispatchedDuring
  ].filter(i => Number.isFinite(i));
  WEEKLY_EDITABLE_COLS = new Set(cols);

  const hint = `Editable weekly columns: ${
    cols.map(i => weeklyHeader[i] || `Col ${i+1}`).join(", ")
  }`;
  document.getElementById("editableHint").innerText = hint;
}

/* =========================
   FIREBASE: WEEKLY EDITS (per week, per SRO)
========================== */
async function loadWeeklyEditsForSelectedWeek(){
  weeklyEdits = {};
  const wk = getWeekKey();
  if(!wk) return;

  toggleLoader(true, "LOADING WEEK EDITS...");
  try{
    const snap = await db.ref(`ufs_weekly_edits/${STATE_NAME}/${wk}`).once("value");
    if(!snap.exists()) return;

    snap.forEach(sroNode => {
      const sro = sroNode.key;
      const obj = sroNode.val() || {};
      Object.entries(obj).forEach(([cellKey,val])=>{
        weeklyEdits[`${sro}::${cellKey}`] = val;
      });
    });
  } finally {
    toggleLoader(false);
  }
}

function getEditedValue(sro, rIndex, cIndex){
  const k = `${sro}::${rIndex}_${cIndex}`;
  if(k in weeklyEdits) return weeklyEdits[k];
  return null;
}

async function saveWeeklyEdit(sro, rIndex, cIndex, val){
  const wk = requireWeekKey();
  if(!wk) return;
  const path = `ufs_weekly_edits/${STATE_NAME}/${wk}/${sro}/${rIndex}_${cIndex}`;
  await db.ref(path).set(val);
  weeklyEdits[`${sro}::${rIndex}_${cIndex}`] = val;
}

async function clearEditsForThisWeek(){
  const wk = requireWeekKey();
  if(!wk) return;
  if(!currentSroUser){
    alert("Select SRO first.");
    return;
  }
  if(!confirm(`Clear edits for ${currentSroUser} for week ${wk}?`)) return;

  toggleLoader(true, "CLEARING...");
  try{
    await db.ref(`ufs_weekly_edits/${STATE_NAME}/${wk}/${currentSroUser}`).remove();
    // purge local keys
    Object.keys(weeklyEdits).forEach(k=>{
      if(k.startsWith(currentSroUser + "::")) delete weeklyEdits[k];
    });
    renderActive();
  } finally {
    toggleLoader(false);
  }
}

/* =========================
   MONTHLY: BUILD FROM TEMPLATE + WEEKLY (WITH EDITS)
   - Monthly display is read-only
========================== */
function cloneGrid(grid){ return grid.map(r => (r||[]).slice()); }

function findMonthlyHeaderRow(grid){
  // Often row 0 is header; if not, pick first row with many non-empty cells
  let best = 0, bestCount = -1;
  for(let r=0;r<Math.min(grid.length, 20);r++){
    const row = grid[r] || [];
    const count = row.filter(x => safeText(x) !== "").length;
    if(count > bestCount){ bestCount = count; best = r; }
  }
  return best;
}

function normalizeSroName(s){
  const t = (s ?? "").toString().trim();
  // Match your monthly template row labels: "Shimla", "Dharamshala", etc.
  return t;
}

function weeklyRowValueWithEdits(rowObj, cIndex){
  const base = rowObj.rowArr[cIndex];
  const edited = getEditedValue(rowObj.sroName, rowObj.rIndex, cIndex);
  return edited !== null ? edited : base;
}

function computeMonthlyFromWeekly(){
  if(!monthlyGridTemplate || !weeklyDataRows?.length) return null;

  const grid = cloneGrid(monthlyGridTemplate);
  const headerRowIdx = findMonthlyHeaderRow(grid);

  // Aggregate weekly by SRO (for this week ending only; but monthly wants month totals)
  // Best approach without extra weekly history files:
  // - treat weekly sheet as "current week snapshot" for "since start" fields
  // - for "during month" totals: sum of weekly "during week" in the file (usually one row per SRO)
  const agg = {};
  const touch = (k) => agg[k] ||= {
    townsPhase: 0,
    townsDuringSum: 0,
    completedSince: 0,
    underSurvey: 0,
    pct: 0,
    blocksDuringSum: 0,
    blocksSince: 0,
    allRespectDuringSum: 0,
    allRespectSince: 0,
    dispatchedDuringSum: 0,
    dispatchedSince: 0
  };

  for(const r of weeklyDataRows){
    const sro = normalizeSroName(r.sroName);
    const a = touch(sro);

    const townsPhase = numeric(weeklyRowValueWithEdits(r, weeklyColMap.townsPhase));
    const townsDuring = numeric(weeklyRowValueWithEdits(r, weeklyColMap.townsDuring));
    const completedSince = numeric(weeklyRowValueWithEdits(r, weeklyColMap.completedSince));
    const underSurvey = numeric(weeklyRowValueWithEdits(r, weeklyColMap.underSurvey));
    const pct = numeric(weeklyRowValueWithEdits(r, weeklyColMap.pct));
    const blocksDuring = numeric(weeklyRowValueWithEdits(r, weeklyColMap.blocksDuring));
    const blocksSince = numeric(weeklyRowValueWithEdits(r, weeklyColMap.blocksSince));
    const allRespectDuring = numeric(weeklyRowValueWithEdits(r, weeklyColMap.allRespectDuring));
    const allRespectSince = numeric(weeklyRowValueWithEdits(r, weeklyColMap.allRespectSince));
    const dispatchedDuring = numeric(weeklyRowValueWithEdits(r, weeklyColMap.dispatchedDuring));
    const dispatchedSince = numeric(weeklyRowValueWithEdits(r, weeklyColMap.dispatchedSince));

    // phase: keep last non-zero
    a.townsPhase = townsPhase || a.townsPhase;

    // during sums (if weekly file has one row per SRO, sum==value)
    a.townsDuringSum += townsDuring;
    a.blocksDuringSum += blocksDuring;
    a.allRespectDuringSum += allRespectDuring;
    a.dispatchedDuringSum += dispatchedDuring;

    // since start: treat as snapshot (latest)
    a.completedSince = completedSince;
    a.underSurvey = underSurvey;
    a.pct = pct;
    a.blocksSince = blocksSince;
    a.allRespectSince = allRespectSince;
    a.dispatchedSince = dispatchedSince;
  }

  // Write into monthly template rows by matching first column label
  function writeMonthlyRow(label, a){
    for(let r=headerRowIdx+1;r<grid.length;r++){
      const row = grid[r] || [];
      const rowLabel = normalizeSroName(row[0]);
      if(rowLabel === label){
        grid[r][MONTHLY_MAP_COLS.townsPhase] = a.townsPhase;
        grid[r][MONTHLY_MAP_COLS.townsDuringMonth] = a.townsDuringSum;
        grid[r][MONTHLY_MAP_COLS.completedSince] = a.completedSince;
        grid[r][MONTHLY_MAP_COLS.underSurvey] = a.underSurvey;

        // pct: calculate if possible from completedSince / townsPhase, else use weekly pct
        const pctCalc = a.townsPhase ? Math.round((a.completedSince / a.townsPhase) * 100) : a.pct;
        grid[r][MONTHLY_MAP_COLS.pct] = pctCalc;

        grid[r][MONTHLY_MAP_COLS.blocksDuringMonth] = a.blocksDuringSum;
        grid[r][MONTHLY_MAP_COLS.blocksSince] = a.blocksSince;
        grid[r][MONTHLY_MAP_COLS.allRespectDuringMonth] = a.allRespectDuringSum;
        grid[r][MONTHLY_MAP_COLS.allRespectSince] = a.allRespectSince;
        grid[r][MONTHLY_MAP_COLS.dispatchedDuringMonth] = a.dispatchedDuringSum;
        grid[r][MONTHLY_MAP_COLS.dispatchedSince] = a.dispatchedSince;
        return;
      }
    }
  }

  for(const sro of UFS_SRO_LIST){
    writeMonthlyRow(sro, agg[sro] || touch(sro));
  }

  // Total row if exists
  const total = touch("Total");
  for(const sro of UFS_SRO_LIST){
    const a = agg[sro] || touch(sro);
    total.townsPhase += Number(a.townsPhase||0);
    total.townsDuringSum += Number(a.townsDuringSum||0);
    total.completedSince += Number(a.completedSince||0);
    total.underSurvey += Number(a.underSurvey||0);
    total.blocksDuringSum += Number(a.blocksDuringSum||0);
    total.blocksSince += Number(a.blocksSince||0);
    total.allRespectDuringSum += Number(a.allRespectDuringSum||0);
    total.allRespectSince += Number(a.allRespectSince||0);
    total.dispatchedDuringSum += Number(a.dispatchedDuringSum||0);
    total.dispatchedSince += Number(a.dispatchedSince||0);
  }
  total.pct = total.townsPhase ? Math.round((total.completedSince / total.townsPhase) * 100) : 0;
  writeMonthlyRow("Total", total);

  return grid;
}

/* =========================
   RENDERING
========================== */
function renderActive(){
  if(activeTab === "weekly") renderWeekly();
  else renderMonthly();
}

function renderWeekly(){
  const head = document.getElementById("tableHeader");
  const body = document.getElementById("dataBody");
  const q = (document.getElementById("q").value || "").toLowerCase();

  if(!weeklyGridRaw || weeklyHeaderRowIdx === null){
    head.innerHTML = `<th>WEEKLY</th>`;
    body.innerHTML = `<tr><td style="padding:28px; opacity:.7;">Weekly not loaded.</td></tr>`;
    return;
  }

  head.innerHTML = weeklyHeader.map(h => `<th>${escapeHtml(h)}</th>`).join("");

  const rows = [];
  for(const r of weeklyDataRows){
    const row = r.rowArr || [];
    const sro = normalizeSroName(r.sroName);

    // search filter
    const rowText = row.map(x => (x ?? "").toString().toLowerCase()).join(" ");
    if(q && !rowText.includes(q) && !sro.toLowerCase().includes(q)) continue;

    let tr = "<tr>";
    for(let c=0;c<weeklyHeader.length;c++){
      const baseVal = row[c] ?? "";
      const editedVal = getEditedValue(sro, r.rIndex, c);
      const displayVal = (editedVal !== null) ? editedVal : baseVal;

      // Editable if:
      // - selected SRO matches this row SRO
      // - col is in WEEKLY_EDITABLE_COLS
      // - weekEnding selected
      const canEdit = !!currentSroUser && currentSroUser === sro && WEEKLY_EDITABLE_COLS.has(c);

      if(canEdit){
        const wk = getWeekKey();
        if(!wk){
          tr += `<td class="cell readonly"><input value="${escapeAttr(displayVal)}" readonly title="Select week ending date to edit"></td>`;
        } else {
          tr += `<td class="cell editable"><input value="${escapeAttr(displayVal)}" onchange="onWeeklyCellChange('${escapeAttr(sro)}',${r.rIndex},${c},this.value)"></td>`;
        }
      } else {
        // Lock "since start" and other cells by making them readonly (display only)
        // We still show edited values if any (from Firebase)
        const cls = (editedVal !== null && WEEKLY_EDITABLE_COLS.has(c)) ? "cell locked" : "cell readonly";
        tr += `<td class="${cls}"><input value="${escapeAttr(displayVal)}" readonly></td>`;
      }
    }
    tr += "</tr>";
    rows.push(tr);
  }

  body.innerHTML = rows.join("") || `<tr><td colspan="${weeklyHeader.length}" style="padding:28px; opacity:.7;">No rows.</td></tr>`;
}

async function onWeeklyCellChange(sro, rIndex, cIndex, value){
  // Sanity: keep numeric if user types
  const v = (value ?? "").toString().trim();
  await saveWeeklyEdit(sro, rIndex, cIndex, v);
  // update monthly computed live if on monthly tab or for export
  monthlyGridComputed = computeMonthlyFromWeekly();
}

function renderMonthly(){
  const head = document.getElementById("tableHeader");
  const body = document.getElementById("dataBody");
  const q = (document.getElementById("q").value || "").toLowerCase();

  if(!monthlyGridTemplate){
    head.innerHTML = `<th>MONTHLY</th>`;
    body.innerHTML = `<tr><td style="padding:28px; opacity:.7;">Monthly template not loaded.</td></tr>`;
    return;
  }

  // Compute (with current weekly edits)
  monthlyGridComputed = computeMonthlyFromWeekly();
  const grid = monthlyGridComputed || monthlyGridTemplate;

  const hdrRowIdx = findMonthlyHeaderRow(grid);
  const hdr = (grid[hdrRowIdx] || []).map(x => (x ?? "").toString());

  head.innerHTML = hdr.map(h => `<th>${escapeHtml(h)}</th>`).join("");

  let html = "";
  for(let r=hdrRowIdx+1;r<grid.length;r++){
    const row = grid[r] || [];
    if(row.every(x => safeText(x) === "")) continue;

    const rowText = row.map(x => (x ?? "").toString().toLowerCase()).join(" ");
    if(q && !rowText.includes(q)) continue;

    html += "<tr>";
    for(let c=0;c<hdr.length;c++){
      const val = row[c] ?? "";
      html += `<td class="cell readonly"><input value="${escapeAttr(val)}" readonly></td>`;
    }
    html += "</tr>";
  }

  body.innerHTML = html || `<tr><td colspan="${hdr.length}" style="padding:28px; opacity:.7;">No rows.</td></tr>`;
}

/* =========================
   EXPORT (XLSX)
========================== */
function gridToSheet(grid){
  const ws = XLSX.utils.aoa_to_sheet(grid);
  return ws;
}

function downloadXlsx(which){
  if(which === "weekly"){
    if(!weeklyGridRaw) return alert("Weekly not loaded.");
    // Apply edits on a copy
    const g = cloneGrid(weeklyGridRaw);
    // Apply edits (only to displayed cells that have edits)
    Object.entries(weeklyEdits).forEach(([k,v])=>{
      const [sro, cellKey] = k.split("::");
      if(!cellKey) return;
      const [rStr, cStr] = cellKey.split("_");
      const r = parseInt(rStr,10), c = parseInt(cStr,10);
      if(Number.isFinite(r) && Number.isFinite(c)){
        if(!g[r]) g[r] = [];
        g[r][c] = v;
      }
    });

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, gridToSheet(g), "Weekly");
    XLSX.writeFile(wb, `UFS_WEEKLY_${STATE_NAME}_${getWeekKey() || "NO_WEEK"}.xlsx`);
  }

  if(which === "monthly"){
    if(!monthlyGridTemplate) return alert("Monthly not loaded.");
    const g = monthlyGridComputed || computeMonthlyFromWeekly() || monthlyGridTemplate;

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, gridToSheet(g), "Monthly");
    XLSX.writeFile(wb, `UFS_MONTHLY_${STATE_NAME}_${sysDateStr}.xlsx`);
  }
}

/* =========================
   MONTHLY SNAPSHOT SAVE
========================== */
async function saveMonthlySnapshot(){
  if(!monthlyGridTemplate) return alert("Monthly not loaded.");
  const g = monthlyGridComputed || computeMonthlyFromWeekly() || monthlyGridTemplate;

  toggleLoader(true, "SAVING SNAPSHOT...");
  try{
    // Save as JSON grid to firebase (lightweight). If you want file storage, do it separately.
    await db.ref(`ufs_monthly_snapshot/${STATE_NAME}/${sysDateStr}`).set({
      updatedAt: Date.now(),
      weekKey: getWeekKey() || null,
      grid: g
    });
    alert("Saved monthly snapshot to Firebase.");
  } finally {
    toggleLoader(false);
  }
}

/* =========================
   MAIN BOOTSTRAP
========================== */
async function reloadAll(){
  try{
    toggleLoader(true, "REFRESHING...");
    // dates
    sysDateStr = document.getElementById("sysDate").value || sysDateStr;
    document.getElementById("sysDate").value = sysDateStr;
    updateMonthPill();

    // default week ending = sysDate if blank
    if(!document.getElementById("weekEnding").value){
      document.getElementById("weekEnding").value = sysDateStr;
    }

    // load xlsx
    await loadXlsxFiles();

    // load weekly edits for selected week
    await loadWeeklyEditsForSelectedWeek();

    // compute monthly
    monthlyGridComputed = computeMonthlyFromWeekly();

    renderActive();
  } catch(e){
    alert(
      "Failed to load XLSX.\n\n" +
      "Make sure both XLSX files are in the SAME folder as this HTML:\n" +
      "1) Weekly MPR RO Shimla Level.xlsx\n" +
      "2) UFS MPR Monthly RO Shimla.xlsx\n\n" +
      "Error: " + e.message
    );
    // render empty
    document.getElementById("tableHeader").innerHTML = "<th>UFS</th>";
    document.getElementById("dataBody").innerHTML = "<tr><td style='padding:28px;opacity:.7;'>Files not found / could not load.</td></tr>";
  } finally {
    toggleLoader(false);
  }
}

/* Load edits again when week changes */
document.addEventListener("change", async (e)=>{
  if(e.target && e.target.id === "weekEnding"){
    await loadWeeklyEditsForSelectedWeek();
    monthlyGridComputed = computeMonthlyFromWeekly();
    renderActive();
  }
  if(e.target && e.target.id === "sysDate"){
    sysDateStr = e.target.value || sysDateStr;
    updateMonthPill();
    monthlyGridComputed = computeMonthlyFromWeekly();
    renderActive();
  }
});

window.onload = () => {
  document.getElementById("sysDate").value = sysDateStr;
  updateMonthPill();
  document.getElementById("weekEnding").value = sysDateStr;
  reloadAll();
};
</script>

</body>
</html>
